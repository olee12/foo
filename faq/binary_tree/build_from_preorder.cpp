/* This program prints out all possible binary trees based on 
 * an input string that is pre-order traversal of the tree. 
 * We assume that each character in input string is a value of
 * binary tree node.
 *
 * Mathematically, the number of binary trees that can be built based
 * pre-order traversal (or in-order and post-order) is Catalan number of N,
 * in which N is the number of nodes (or, in this problem, the number of
 * characters in input string.
 * Instead of printing out the binary tree as a graph, we print it as a string, 
 * which is generated by in-order traversal. The null node is denoted as 'X'.
 * (We assume that the input string does not include 'X' character.)
 */

#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct Node {
  Node(char c) { dat = c; left = 0; right = 0; }

  char dat;
  Node* left;
  Node* right;
};

/* Build a binary tree based on input string.
 * Returns all valid trees as a vector of strings of in-order traversal. */
vector<string> buildTree(const string& str) 
{
  vector<string> ret;
  if (!str.size()) {
    string tmp("X");
    ret.push_back(tmp);
    return ret;
  }

  string root(1, str[0]);
  for (size_t i = 0; i < str.size(); i++) {
    string left_str = str.substr(1, i);
    string right_str = str.substr(1 + i);
    vector<string> lefts = buildTree(left_str);
    vector<string> rights = buildTree(right_str);
    for (size_t i = 0; i < lefts.size(); i++) {
      for (size_t j = 0; j < rights.size(); j++) 
	ret.push_back(lefts[i] + root + rights[j]);
    }
  }

  return ret;
}

// Test harness
int main() 
{
  string foo("1234");
  vector<string> trees = buildTree(foo);
  for (size_t i = 0; i < trees.size(); i++)
    cout << trees[i] << endl;

  return 0;
}
