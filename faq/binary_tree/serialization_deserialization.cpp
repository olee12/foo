/* This program implements serialization and de-serialization of binary tree.
 * It tests pre-order, in-order and post-order traversals.
 * In this program, we assume that each node has single digit numerical data.
 * When serializing the tree, NULL node is denoted as 'X'.
 *
 * Note that we can not build a unique binary tree based on pre-order traversal 
 * and post-order traversal. For example, suppose we have pre-order traversal string
 * of "12", and post-order traversal string of "21", there will be two binary trees 
 * that satisfy: 
 * :
 *           1                 1
 *          /       or:         \         
 *         2                     2
 *
 * Another more complexed example is: suppose we have pre-order traversal string of 
 * "12435" and post-order traversal string of "42531". the binary tree can be built 
 * as either:
 *              1                       1
 *             / \                     / \
 *            2   3         or:       2   3
 *           /     \                   \   \
 *          4       5                   4   5
 *         
 *        
 * It seems to be straightforward to de-serialize a string that was generated by 
 * pre-order or post-order serialization back into the orginal binary tree, the 
 * following algorithm is based on:
 *
 * http://www.leetcode.com/2010/09/serializationdeserialization-of-binary.html
 *
 * Also note that in-order serialization string can not determine a unique 
 * binary tree. For example, the following two binary trees:
 *
 *              1                       1
 *             / \                     / \
 *            2   3         and       4   3
 *           /     \                   \   \
 *          4       5                   2   5
 *         
 * will have same in-order serialization string: x4x2x1x3x5x
 * As a matter of fact, in-order serialization string will be always in the format 
 * of: x <node_dat> x <node_dat> ... x
 *
 * IMPORTANT: This problem is closed related to the one of building expression tree.
 *            See expr_tree.cpp
 */

#include <iostream>
#include <string>

using namespace std;

// Binary tree node structure
struct Node {
  Node(const string& str) { dat = str; left = 0; right = 0; }

  string dat;
  Node* left;
  Node* right;
};

// Pre-order traversal
string serialize_pre_order(const Node* curr_node, bool skipNull) 
{
  string str;
  if (!curr_node) {
    if (!skipNull)
      str += "x";
    return str;
  }

  str += curr_node->dat;
  str += serialize_pre_order(curr_node->left, skipNull);
  str += serialize_pre_order(curr_node->right, skipNull);

  return str;
}

// In-order traversal
string serialize_in_order(const Node* curr_node, bool skipNull) 
{
  string str;
  if (!curr_node) {
    if (!skipNull)
      str += "x";
    return str;
  }

  str += serialize_in_order(curr_node->left, skipNull);
  str += curr_node->dat;
  str += serialize_in_order(curr_node->right, skipNull);

  return str;
}

// Post-order traversal
string serialize_post_order(const Node* curr_node, bool skipNull) 
{
  string str;
  if (!curr_node) {
    if (!skipNull)
      str += "x";
    return str;
  }

  str += serialize_post_order(curr_node->left, skipNull);
  str += serialize_post_order(curr_node->right, skipNull);
  str += curr_node->dat;

  return str;
}

// De-serialize an input string that was generated from pre-order serialization
Node* deserialize_pre_order(const string& str, size_t& level) 
{
  if (level == str.size())
    return 0;


  if (str[level] == 'x') {
    level++;
    return 0;
  }

  string tmp = str.substr(level, 1);
  Node* root = new Node(tmp);
  level++;
  root->left = deserialize_pre_order(str, level);
  root->right = deserialize_pre_order(str, level);
  return root;
}

// De-serialize an input string that was generated from pre-order serialization
Node* deserialize_post_order(const string& str, int& level) 
{
  if (level == -1)
    return 0;


  if (str[level] == 'x') {
    level--;
    return 0;
  }

  string tmp = str.substr(level, 1);
  Node* root = new Node(tmp);
  level--;
  root->right = deserialize_post_order(str, level);
  root->left = deserialize_post_order(str, level);
  return root;
}

// Test harness
int main() {
  Node* n1 = new Node("1");
  Node* n2 = new Node("2");
  Node* n3 = new Node("3");
  Node* n4 = new Node("4");
  Node* n5 = new Node("5");

  n1->left = n2;
  n1->right = n3;
  n2->right = n4;
  n3->right = n5;

  string str = serialize_post_order(n1, false);
  cout << "old: " << str << endl;

  int level = str.size() - 1;
  Node* dup = deserialize_post_order(str, level);
  cout << "New: " << serialize_post_order(dup, false) << endl;
}














