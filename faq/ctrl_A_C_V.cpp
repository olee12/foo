/* A, ctrl+A, Ctrl+C, Ctrl+V problem, based on:
 * http://www.ihas1337code.com/2011/01/ctrla-ctrlc-ctrlv.html
 * http://www.mitbbs.com/article_t/JobHunting/31762933.html
 */

#include <iostream>
#include <cmath>
#include <cassert>

using namespace std;

/* Test every possible k, starting from k = 2, until a[1]+a[2]+a[k] <= 0.
 * Because a[1] + a[2]+... + a[k] = n - 2 * (k - 1) and abs(a[i] - a[j]) <= 1, 
 * every time k increases by 1, a[1]+a[2]+...+a[k] will decrease by 2.
 * dhu: actually we don't have to iterate until a[1]+a[2]+a[k] <= 0, 
 * because when k increases, the product a[1]*a[2]*...*a[k] will always increase first, 
 * reach the maximum, then decrease. So if we record the previous product, then compare 
 * it with the current one, if it decreases, terminate the iteration.
 * Or we can terminate the interation when t <= 1, that is, when n <= power.
 * 
 * BUG: when n is 33, this function should return 5, but it returns 6, 
 * which is incorrect.
 *
 */
int findMaxK_old(int n) {
  //if (n == 33)
  // return 5;

  int power = 1;
  double max = 0.0;
  int maxK = 0;
  while (n > 0) {
    n -= 2;
    power++;
    double t = (double) n / power;
    /* The max we want to get is actually an integer, but the following line
     * uses a double value to evaluate the max. This is why the bug is generated.
     */
    double r = pow(t, (double) power);
    if (r > max) {
      maxK = power;
      max = r;
    }
    cout << "n: " << n << endl;
    cout << "maxK: " << maxK << endl;
    cout << "max: " << max << endl << endl;
  }

  return maxK;
}

/* Algorithm given in leetcode website. 
 * This algorithm is buggy. When n is 33, the other algorithms returns 3125,
 * but this algorithm returns 3072, which is not correct, because when n is 26,
 * all algorithms return 625. So 3125 can be generated by Ctrl+A, Ctrl+C, Ctrl+V,
 * Ctrl+V, Ctrl+V, Ctrl+V, Ctrl+V, which is 625 * 5 = 3125.
 */ 
unsigned int leetcode(int n) {
  if (n <= 7) 
    return n;

  int k = findMaxK(n);
  
  // sum equals a[1] + a[2] + ... + a[k]
  int sum = n - 2 * (k - 1);
  unsigned int mul = 1;
  while (k > 0) {
    int avg = sum / k;
    mul *= avg;
    k--;
    sum -= avg;
  }
 
  assert(sum == 0);
 
  return mul;
}

/* Dynamic Programming with O(n^3), by Anonymous.
 * Let M(i, j) denote the maximum number of A we can get by pressing A for i times 
 * and using totally j keys (i <= j), then the recursion is as follows:
 * M(i, j) = max { k = [i+3 ... j] } { M(i, k-3) * (j-k+1) }, 
 * where i = [1 ... N], j = [i ... N]
 */
int DP_n3(int n) {
  if (n <= 7) 
    return n;
    
  int* M = new int[n+1];
  for (int i = 0; i <= n; i++)
    M[i] = 0;

  int maxa = 0;
  // Each iteration of i updates M[i], M[i+1], ... M[n]
  for (int i = 1; i <= n; i++) {
    M[i] = i;
    for (int j = i; j <= n; j++) {
      for (int k = i+3; k <= j; k++) {
	if (M[j] < (j-k+1) * M[k-3])
	  M[j] = (j-k+1) * M[k-3];
      }
    }
    if (M[n] > maxa) 
      maxa = M[n];
  }

  delete[] M;
  return maxa;
}

/* Dynamic Programming with O(n^2), by Constantin Ungureanu. 
 * Very straightforward, I like it.
 */
int DP_n2(int n) {
  int* s = new int[n+1];
  for(int i = 1; i <= n; ++i) 
    s[i] = i;

  // In each iteration of i, update s[i+4], s[i+5], ..., s[n]
  for (int i = 1; i <= n - 4; ++i) {
    int val = 2 * s[i];
    if(s[i+4] < val) // update s[i+4]
      s[i+4] = val;
   
    int delta = s[i];
    // update s[i+5], ... s[n]
    for (int j = i + 5; j <= n; ++j) { 
      val += delta;
      if(val > s[j]) 
	s[j] = val;
    }
  }

  int result = s[n];
  delete[] s;
  return result;
} 

// Dynamic Programming by Raynor, similar to DP_n2()
int DP_Raynor(int n) {
  int* M = new int[n];
  M[0] = 1;
  for (int i = 1; i < n; i += 1) {
    int maxi = 0;
    maxi = maxi > (1+M[i-1]) ? maxi : (1 + M[i-1]);
    for (int k = 0; k <= i-4; k++) {
      int temp = M[k] + (i-k-3) * M[k];
      maxi = maxi > temp ? maxi : temp;
    }
    M[i] = maxi;
  }

  int result = M[n-1];
  delete[] M;
  return result;
} 

int main() {
  //int n = 26;
  //cout << leetcode(33) << endl;
  //cout << DP_n3(n) << endl;
  //cout << DP_n2(n) << endl;
  //cout << DP_Raynor(n) << endl;
  //cout << findMaxK(26) << endl;
  cout << findMaxK(33) << endl;

  return 0;
}



