/****************************************************************************
 * Generate Gray code recursively. 
 * C++ code is based on java code on slide #36. 
 *
 * This amazingly simple implementation is modified from
 * enumerate.cpp.
 *
 * Slide #37 mentioned the relationship between "Hanoi Towers"
 * problem and Gray code:   
 * 
 * "move i-th smallest disk when bit i changes in Gray code".
 *
 * Suppose we have three discs (Call them A, B, C from large to small),
 * and our goal is to move ABC from stack #1 (s1) to stack #3 (s3), with
 * the help of stack #2 (s2). Here is a detailed correspondence between 
 * these two problems:
 *
 *  Gray Code        Hanoi Tower
 *  sequences        s1   s2   s3
 * --------------------------------------------------------------------
 *    0 0 0           ABC  __   __    (initial state)
 *    0 0 1           AB   __   C     (move C from s1 to s3)
 *    0 1 1           A    B    C     (move B from s1 to s2)
 *    0 1 0           A    BC   __    (move C from s3 to s2)
 *    1 1 0           __   BC   A     (move A from s1 to s3)
 *    1 1 1           C    B    A     (move C from s2 to s1)
 *    1 0 1           C    __   AB    (move B from s2 to s3)
 *    1 0 0           __   __   ABC   (move C from s1 to s3, done)
 *
 *
 ************************************************************************
 * According to wikipedia, the i-th gray code can be generated by:
 *    G(i) = (i >> 1) ^ i
 * Here is a proof of why this equation is correct:
 *
 * (1) First, we prove that for any N-bit integer i that is in the range 
 * of [0, (1 << N) - 2], only one bit is different between G(i) and G(i + 1).
 * 
 * When i = (1 << N) - 1, i + 1 will overflow, that is why 
 *     0 <= i <= (1 << N) - 2    
 * Any int i in this range can be written as: 
 *         i = [x...x]0[1...1]
 * in which the leading [x...x] are m digits of random 0/1's, and the 
 * number of trailing 1's is N-m-1, then:
 *     i + 1 = [x...x]1[0...0]  (number of tailing 0's is also N-m-1)
 * So:  
 *     i ^ (i+1) 
 *   = [x...x]0[1...1] ^ [x...x]1[0...0] 
 *   = [0...0]1[1...1] 
 * In another word, i^(i+1) is composed of m leading 0's and N-m trailing 1's.
 * 
 * And:
 *     (i >> 1) ^ ((i+1) >> 1)
 *   = 0[x...x]0[1..1] ^ 0[x...x]1[0..0]
 *   = 0[0...0]1[1..1]
 * aka. (i >> 1) ^ ((i+1) >> 1) is composed of m+1 leading 0's and N-m-1 trailing 1's.
 * 
 * We know that:
 *     G(i) ^ G(i + 1) 
 *   = ((i >> 1) ^ i) ^ (((i+1) >> 1) ^ (i+1))
 *   = ( (i >> 1) ^ ((i+1) >> 1) )   ^   ( i ^ (i+1) )
 * So G(i) ^ G(i + 1) = [0...0]1[0...0], only one bit is changed from G(i) to G(i+1).  
 * 
 * (2) Now we prove that for any two N-bit integers i and j, 
 * if i != j, then G(i) and G(j) will never be equal.
 *
 * Assume that G(i) == G(j), then G(i) ^G(j) = 0, aka:
 * (i>>1) ^ i ^ (j>>1) ^ j = 0, 
 * this will be true only when i == j, so G(i) and G(j) will never equal.
 * 
 * We can prove this by another method: 
 * Assume i < j and G(i) == G(j),
 * a) If i == 0, because G(0) = 0, so G(j) = (j>>1) ^ j = 0,
 *    aka. j>>1 == j
 * This will never be true for any non-zero integer.
 *
 * b) If i > 0, then because G(i-1) has only one bit difference from G(i),
 * and G(j-1) has only one bit difference from G(j), so G(i-1) == G(j-1),
 * Keep decreasing i and j, eventually i reaches 0, G(j') = G(0), 
 * because G(0) = 0, so G(j') = (j'>>1) ^ j' = 0, 
 * For the same reason as a), we know that such j' will never exist.
 * 
 * Combining proof (1) and (2), we conclude that G(i) does generate valid 
 * Gray code. 
 * Q.E.D.
 */ 

#include <iostream>
#include <vector>

using namespace std;

const int N = 3;
vector<int> a(N);

// Print out a[]
void process() {
  for (int i = 0; i < N; i++) 
    cout << a[i] << " ";
  cout << endl;
}

// Generate Gray code bit strings in a[k] to a[N-1]
void gray_code(int k) {
  if (k == N) { 
    process(); 
    return; 
  }

  gray_code(k + 1);

  a[k] = 1 - a[k]; // Toggle k-th bit

  gray_code(k + 1);

  // No need to clean up, because we need to keep the new configuration of a[].
}

// Test harness
int main() {
  gray_code(0);

  return 0;
}
